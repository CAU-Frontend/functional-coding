# 계층형 설계

소프트웨어를 계층으로 구성하는 기술
계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의함

바로 아래 단계의 추상화단계를 사용하는 것이 가장 생산성이 높고, 의존하고 있는 추상화를 제공하는 내부 값이 변경되었을 때도 영향을 받지 않기때문임

하지만, 계층을 명확하게 구분하기란 어려움

## 직접 구현

각 함수는 자신이 반드시 알아야하는 값만을 담을 필요가 있음 -> **바로 직전단계의 추상화에 의존해야함**. 다른 값이 의존하면, 가독성, 유지보수성이 떨어지기 시작함

### 호출 그래프

호출그래프를 통해 함수가 의존하고 있는 함수들을 시각화할 수 있음
시각화된 함수들이 어떤 계층인지 구분해볼 필요가 있음
이는 함수들, 계층간에 대한 단서들을 제공함

가장 대표적인 계층 구분은 언어레벨의 추상와인가? 직접 만든 추상화인가? 가 될 수 있음

이때, 서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이라고 할 수 없음.

### 같은 목적

같은 계층에 있는 함수는 같은 목적을 가져야함
예를들면 아래와 같이 목적을 구분하고, 함수 계층을 나눌 수 있음

1. 장바구니 비즈니스 규칙
2. 일반적인 비즈니스 규칙
3. 장바구니 기본동작
4. 제품에 대한 기본 동작
5. 카피-온-라이트 동작
6. JS언어 기능

이 경우, 장바구니 기본동작은 제품에 대한 기본 동작이 어떻게 작동하는지는 알 필요가 없음
아래 레벨에 대해서는 더욱더 알 필요가 없음

그러나, 이때 각 레벨 바로 아래가 아닌 레벨에 의존하게되면, 해당 계층은 다른 계층이 어떻게 동작해야하는지 알 필요가 있음 -> 개발자는 더 많은 context를 이해해야함

### 직접 구현 패턴

1. 일반적인 함수가 많을 수록 재사용하기 좋음
   함수로 빼내면 재사용할 수 있는 곳이 보이기 시작함
   **중복코드를 찾아서 빼내는것과 다름**
2. 복잡성을 감추지 않음
   **그냥 함수에 이름을 붙여 빼내는 것(캡슐화)과는 명확하게 다름**, 물론 이게 나쁘다는 것은 아니나 이게 계층형 설계를 뜻하지는 않음
3. 문제 해결을 위한 함수 구현시 어떤 구체화 단계로 쓸지 고민해볼 필요가 있음 -> 어떤 계층에 속할지 알 수 있게 됨.

# 추상화 벽

추상화벽 : 세부구현을 감춘 함수로 이뤄진 계층 => API (Application Interface)
추상화벽에 위치한 함수를 사용하면, 구현을 몰라도 함수를 쓸 수 있음
**인터페이스가 바뀌지않는한, 세부 내용은 알 필요가 없다.**

```ts
import { authorize, AuthorizeResult } from 'react-native-app-auth';

type GoogleLoginToken = Pick<
AuthorizeResult,
'accessToken' | 'refreshToken' | 'accessTokenExpirationDate'
>;

export default function useGoogleLogin() {

	const [token, setToken] = useState<GoogleLoginToken>();

	const login = async () => {

		try {
			const result = await authorize(GOOGLE_AUTH_CONFIG); //authorize가 어떻게 작동하는지는 알 필요가 없다. 하지만, 추상화되어 제공되기 때문에 사용할 수 있다.

			setToken({
				accessToken: result.accessToken,
				accessTokenExpirationDate: result.accessTokenExpirationDate,
				refreshToken: result.refreshToken,
			});

		} catch (err: any) {
			...
		}
	}

	...
}
```

### 추상화벽을 사용하면 좋은 경우

1. 쉽게 구현을 바꾸기 위해
2. 코드를 읽고 쓰기 쉽게 만들기 위해
3. 팀간 조율해야할 것을 줄이기위해
4. 주어진 문제에 집중하기위해

2,3,4 모두 따지고보면 1번으로부터 파생된 것이라고 볼 수 있을 듯
`팀간 조율 -> 변경이 잦다 -> 구현을 바꿔야한다 -> 쉽게 구현을 바꾸기 쉬운 추상화벽을 사용하자`
의 형태

### 추상화벽의 동작방식

1. 추상화 단계 상위코드와 하위 코드는 서로 의존하지 않아야한다. (의존 방향이 아래로 단방향이어야한다)
2. 추상화 단계의 모든 함수는 세부 사항을 무시할 수 있도록 정의한다
3. 추상화벽으로 추상화를 강력하고 명시적으로 만들 수 있다.

=> 팀 간 커뮤니케이션 비용을 줄이고, 복잡한 코드를 명확하게 하기위해 전략적으로 사용해야한다

[당근 알바팀 발표](https://www.youtube.com/watch?v=pD807v7AJeg)를 봤었는데, 여기도 똑같은 내용이 언급됨
여기서는 GraphQL을 사용하여 백엔드-프론트엔드간의 **스키마**라는 인터페이스로 REST API의 한계를 극복한 사례를 발표함
![](https://i.imgur.com/C4hJPPI.png)
![](https://i.imgur.com/FniIeZF.png)

## 작은 인터페이스

인터페이스를 크게 만들게되면, 계약이 늘어나고, 알아야할 것이 많아짐
즉, 소통 비용이 추가되는 것이라 생각할 수 있음

라이브러리를 도입했는데, 버전 업데이트가 되면서 인터페이스가 추가되고, 신기능이 추가되었는데, 이게 꼭 필요한 경우라면?
=> 라이브러리 docs를 또 읽어야함, 알아야할 것이 많아짐
=> 다시 익숙해져야함

빠른 업데이트도 좋지만, 그로 인해 인터페이스를 바꿨던 [그들...](https://nextjs.org/)
그리고 아직도 12버전에 익숙한 나..

**인터페이스에 어떤 것을 추가, 변경하기보다는 상위 레이어에서 기능을 추가하는게 비용이 적을 수 있음**
물론, 항상 그런 것은 아니고 꼭 필요하다면 추가해야...

## 편리한 계층

커다란 계층을 만들면 뿌듯함
그러나 굉장히 굉장히 만들기 힘들고, 시간이 지나면 필요없고 오히려 장애물이 되기도함

1. 지금 편리하다면, 지금 작업하는 코드가 편리하다고 느낀다면 설계는 조금 멈춰도됨
2. 구체적인 것을 너무 많이 알아야하거나 코드가 지저분하다고 느껴진다면 다시 패턴을 적용할 때
3. 언제나 우리는 설계와 새로운 기능의 필요성 사이 어느 지점에 머물게됨

## 호출그래프 관련 정보

1. 가장 상위 레이어가 고치기 쉬움 -> 변동성이 높은 코드는 상위레이어에 둘 것
2. 하위레이어에 대한 테스트가 중요함 -> 전체적인 신뢰도를 높힐 수 있게됨, 많이 호출된다면 중요도가 더 높아짐
3. 하위레이어의 재사용성이 더 좋음

# 일급 추상

## 일급

일급은 함수의 인자로 넘길 수 있다는 의미를 가짐
정확하게 말하면 일급은 아래 행동을 할 수 있음

1. 변수에 할당
2. 함수의 인자로 넘기기
3. 함수의 리턴값으로 받기
4. 배열이나 객체에 담기

일급이 아닌것 -> + 등 연산자, for, const와 같은 예약어

함수의 이름만 살짝 다르고, 기능 구현이 동일한 내용으로 반복되는 경우
-> 함수의 이름에서 정보를 표현하는 부분을 변수로 만들고, 인자로 만들 수 있음
=> 함수의 이름은 본래 일급이 아니나, 변경을 통해 인자로 넘길 수 있는 값이 됨 -> 일급이 됐음

### 일급화

어떤 문법이든 일급함수로 바꿀 수 있음 +연산자는 일급이 아니나, 함수로 바꾸면 일급이됨
=> 모든 로직을 일급으로 바꿀 수 있다는 것.

### 콜백

함수 본문을 콜백으로 바꾸면 행동 자체를 추상화 할 수 있게 됨
일급이기때문에 가능한것

이걸 활용하면, 나아가 리액트의 고차컴포넌트(HOC)도 같은 의미라는 것을 이해할 수 있음
아래 코드는 Component를 Suspense로 묶어서 리턴해주는 팩토리 고차함수인 것

```tsx
import Loading from '@/components/common/Loading';
import React, { Suspense } from 'react';

interface WithSuspenseOptions {
  fallback?: React.ReactNode;
}

export default function withSuspense<T extends object>(
  Component: React.ComponentType<T>,
  options: WithSuspenseOptions = { fallback: <Loading /> }
) {
  return function SuspenseComponent({ ...props }: T) {
    return (
      <Suspense fallback={options.fallback}>
        <Component {...props} />
      </Suspense>
    );
  };
}
```

# 계층형 설계 I

### 소프트웨어 설계란?

- 설계를 잘하면 개발 과정 전체에 도움
- 코드 작성, 테스트, 유지보수가 용이한 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

### 계층혈 설계란?

- 소프트웨어를 계층으로 구성하는 기술
- 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의
- ex)
  - 비즈니스 규칙 -> 장바구니 동작 -> 카피-온-라이트 -> 배열 관련 기능

### 계층형 설계 감각을 키우기 위한 입력

- 다양한 입력을 생각해볼 수 있음
- 이러한 입력들은 계층형 설계에 대한 단서
- 코드를 읽고, 단서를 찾고, 계층형 설계를 위한 길잡이로 사용
- ex)
  - 함수 본문
    - 길이
    - 복잡성
    - 구체화 단계
    - 함수 호출
  - 계층 구조
    - 화살표 길이
    - 응집도
    - 구체화 단계
  - 함수 시그니쳐
    - 함수명
    - 인자이름
    - 인자
    - 리턴값

### 계층형 설계 감각을 키우기 위한 출력

- ex)
  - 조직화
    - 새로운 함수를 어디에 놓을지 결정
    - 함수를 다른 곳으로 이동
  - 구현
    - 구현 바꾸기
    - 함수 추출하기
    - 데이터 구조 바꾸기
  - 변경
    - 새 코드를 작성할 곳 선택하기
    - 적절한 수준의 구체화 단계 결정하기

## 계층형 설계 패턴

**패턴 1 - 직접구현**

- 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 잇는 문제를 함수 본문에서 적절한 구체화 수준에서 해결

**패턴 2 - 추상화 벽**

- 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스 제공
- 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각 가능

**패턴 3 - 작은 인터페이스**

- 시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성
- 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의

**패턴 4 - 편리한 계층**

- 코드와 그 코드가 속한 추상화 계층은 작업 시 편리해야 함

## 패턴 1 - 직접 구현현

- off-by-one 에러

* 배열을 반복문으로 처리할 때, 크다 or 크거나 같다와 같은 비교문을 잘못 선택해 마지막 항목을 처리하지 못한 오류를 뜻함

### 호출 그래프를 만들어 함수 호출 시각화

- 함수에서 사용하는 다른 함수와 언어에서 제공하는 기능을 호출 그래프로 그릴 수 있음
- 반복문, 배열 인덱스 참조, 호출한 함수가 해당 함수 아래에 위치
- 반복문이나 배열 인덱스 참조 기능은 언어에서 제공하는 기능, 호출한 함수는 직접 작성한 코드
- 두 가지는 추상화 수준이 다름
- 반복문과 배열 인덱스를 참조하는 기능이 더 낮은 추상화 단계
- 이 함수는 여러 계층을 사용하고 있다는 것을 알 수 있음

**한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아서 가독성 저하!**

**한 함수가 모두 비슷한 계층을 사용했다면 직접 구현 패턴!**

### 그래프 확장

- 기존 함수 그래프 옆에 다른 함수 그래프를 붙여 전체 그래프 확장
- 다른 함수 그래프는 어느 계층에 붙여야 하는지 고민
- 함수 이름을 확인
- 같은 박스를 가리킨다는 것은 같은 계층에 있어도 좋다는 정보

각 계층은 추상화 수준이 다르다.

- 계층에 목적은 각 계층에 있는 함수의 목적과 같다.
- 어떤 계층에 있는 함수를 읽거나 고칠 때, 낮은 수준의 구체적인 내용은 신경 쓰지 않아도 된다.

## 3단계 줌 레벨

계층형 설게에서 문제는 3가지 다른 영역에서 찾을 수 있다.

1. 계층 사이에 상호 관계
2. 특정 계층의 구현
3. 특정 함수의 구현

### 1. 전역 줌 레벨

- 그래프 전체 중 필요한 부분을 살펴볼 수 있다.
- 계층 사이에 상호 관계를 포함해서 모든 문제 영역을 살펴볼 수 있다.

### 2. 계층 줌 레벨

- 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨
- 어떻게 계층이 구현되어 있는지 알 수 있다.

### 3. 함수 줌 레벨

- 함수 하나와 바로 아래 연결된 함수들을 볼 수 있다.
- 함수 구현의 문제를 찾을 수 있다.

직접 구현 패턴을 사용하면 모든 화살표가 같은 길이를 가져야 함

- 다양한 계층을 넘나드는 것은 같은 구체화 수준이 아니라는 것

해결 방법

- 언어 기능과 함수 호출 2가지를 사용하고 있어서 화살표 길이가 다르다면
  - 언어 기능을 사용하는 함수를 만들어서 호출하도록 하면 된다.

**더 일반적인 함수라면 조금 더 낮은 계층**
IndexOfItem() 함수가 removeItems() 보다 더 높은 계층

- removeItems() 배열 구조 몰라도 되기 때문
  IsInCart() 함수가 indexOfItem() 보다 더 높은 계층
- indexOfItem()은 배열이라는 것을 알아야 함

몰라도 되면면 낮은 계층이랬는데...?

### 직접 구현 패턴

**직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결**

- 구체화 단계가 다르면 이해하기 어려움
- 직접 구현하면 구체화 단계 범위 줄일 수 있음
  **계층형 설계는 특정 구체화 단계에 집중 가능**
- 호출 그래프는 함수가 서로 어떻게 연결되어 있는지 보여줌
- 다양한 단서를 가지고 직접 코드 패턴 적용 가능
  **함수를 호출하면 더 일반적인 함수로 만들 수 있음**
- 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 분리
  **일반적인 함수가 많을수록 재사용 용이**
- 구현을 명확하게 하기 위해 일반적인 함수를 분리하는 것
- 일반 함수는 구체적 함수보다 더 많은 곳에서 사용 가능
- 따로 찾지 않아도 재사용 가능한 곳을 발견 가능

**복잡성을 감추지 않음**

- 모든 계층은 바로 아래 계층에 의존
- 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 직접 구현 패턴을 적용해야 함

## 패턴 2 - 추상화 벽

- 추상화 벽은 여러 문제를 해결
- 팀 간 책임을 명확하게 나누는 것

### 추상화 벽으로 구현 감추기

- 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수를 사용 시에는 구현을 전혀 몰라도 함수 사용 가능

### 세부적인 것을 감추는 것은 대칭적

- 신경쓰지 않아도 된다는 것은 대칭적이라는 뜻
- 라이브러리나 api를 보면 앎
- 라이브러리나 api를 만드는 사람은 이것이 사용되는 서비스에 대해서 알 필요가 없음
- 서비스 개발자도 해당하는 도구를 신경쓰지 않아도 됨

성능 문제를 깔끔한 인터페이스로 감춰 해결할 수는 없음
배열 대신 자바스크립트 객체를 해시 맵처럼 사용하여 항목 추가 및 제거, 항목 요소 확인 등을 하는 것이 배열을 순서대로 검색하는 것보다 빠름

### 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됨

- 배열 대신 자바스크립트 객체를 해시 맵처럼 사용하려면 추상화 벽에 있는 함수들을 고쳐야 함
- 그 이유는 나머지 함수들은 배열인지 객체인지 알 필요가 없기 때문
- 계층 구조에서 어떤 계층에 있는 함수들이 공통된 개념을 신경 쓰지 않아도 된다면 그 계층을 추상화 벽이라 함

### 추상화 벽은 언제 사용하는 것이 좋을까

**1. 쉽게 구현을 바꾸기 위해**

- 구현에 대한 확신이 없는 경우, 추상화 벽을 사용하면 구현을 간접적으로 사용 가능
  - 구현을 바꾸기 쉬움
  - 프로토타이핑과 같이 최선의 구현을 확신할 수 없는 작업에 유용
- 뭔가 바뀔 것을 알고 있지만, 아직 준비되지 않은 경우

**2. 코드를 읽고 쓰기 쉽게 만들기 위해**

- 세부적인 것을 신경쓰지 않아도 됨
- 적절한 것을 감추면 숙련된 프로그래머가 아니라도 더 생산적인 코드 작성 가능

**3. 팀 간에 조율해야 할 것을 줄이기 위해**

- 추상화 벽을 기준으로 위, 아래 팀은 서로를 확인하지 않고 코드 작성 가능

**4. 주어진 문제에 집중하기 위해**

- 문제를 해결하기 용이
- 해결하려는 문제의 구체적인 부분을 무시할 수 있음

### 패턴 2 - 추상화 벽 리뷰

- 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성 제거 가능
- 추상화 벽 위에 코드는 데이터 구조와 같은 구체적인 내용을 신경쓰지 않아도 됨
- 추상화 벽 아래에 코드는 함수가 어떻게 사용되는지 몰라도 됨
- 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의
- 코드를 쉽게 고치려고 추상화 벽을 사용하는 것은 아님
- 신경 쓰지 않아도 되는 것이 추상화 벽의 핵심

## 패턴 3 - 작은 인터페이스

- 새로운 코드를 추가할 위치에 관한 내용
- 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 방지
- 새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴
- 함수를 잘못 놓으면 액션이 전체로 퍼질 가능성이 있음 => 테스트, 재사용성 저하

### 패턴 3 - 작은 인터페이스 리뷰

- 추상화 벽에 만든 함수는 인터페이스라고 볼 수 있음
- 어떤 값의 집합에 접근하거나 값을 조작할 수 있음
- 추상화 벽을 작게 만들어야 하는 이유
  - 1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것들이 많아짐
  - 2. 추상화 벽에 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있음
  - 3. 낮은 수준의 코드는 이해하기 더 어려움
  - 4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아짐
  - 5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어려움

## 패턴 4 - 편리한 계층

- 앞에 3가지 패턴은 계층을 구성하는 것에 관한 패턴, 계층 구성을 만드는 방법에 대한 설명
- 이번 패턴은 조금 더 현실적이고 실용적인 측면을 다룸

- 언제 패턴을 적용하고, 언제 멈춰야 하는지 실용적인 방법을 알려줌

### 그래프로 알 수 있는 코드에 대한 정보

- 기능적 요구사항

  - 소프트웨어가 정확히 해야하는 일

- 비기능적 요구사항

  - 테스트를 어떻게 할 것인지, 재사용이 용이한지, 유지보수하기 좋은지와 같은 요구사항

- 호출 그래프의 구조는 3가지 중요한 비기능적 요구사항을 보여줌

  - 1. 유지보수성
  - 2. 테스트성
  - 3. 재사용성

### 그래프 가장 위에 있는 코드가 고치기 가장 쉬움

- 가장 낮은 계층에 있는 코드는 위에 의존하는 코드를 많이 만들었기 때문에 어려움
- 가장 높은 계층에 있는 코드는 아무 곳에서도 호출하지 않기 때문에 변경 쉬움
- 자주 바뀌는 코드는 그래프 위에 있을수록 용이, 바뀌는 것이 많은 가장 높은 곳은 적게 유지하는 것이 좋음

### 그래프 가장 아래에 있는 코드 테스트가 중요

- 아래 코드는 자주 바뀌지 않아서 테스트가 중요
- 위에 코드는 자주 바뀌기 때문에 테스트 수명이 짧음

### 그래프 아래에 있는 코드가 재사용 용이

- 위에 함수일수록 아래를 가리키는 화살표가 많아서 재사용하기 어려움
- 아래일수록 재사용 용이

# 일급 함수

## 코드의 냄새와 리팩토링

### 코드의 냄새: 함수 이름에 암묵적 인자

- 함수 이름에 있는 암묵적 인자는 코드의 냄새가 된다.
- 값을 명시적으로 전달하지 않고, 함수 이름의 일부로 전달 중

### 리팩토링: 암묵적 인자 드러내기

- 암묵적 인자가 일급 값이 되도록 함수에 인자를 추가
- 단계
  - 1. 함수 이름에 있는 암묵적 인자 확인
  - 2. 명시적 인자 추가
  - 3. 함수에 하드코딩 값을 새로운 인자로 변경
  - 4. 함수 호출 위치 변경
- 함수 이름에 일부를 인자로 사용하던 함수들을 하나의 일반적인 함수로 변경
- 일반 함수로 변경 후 인자를 명시적으로 드러내기
- 암묵적 인자를 명시적 인자로 넘길 수 있는 값으로 변경했음
- 값은 변수나 배열에 담을 수 있기 때문에 **일급**이라고 부름

### 리팩토링: 함수 본문 콜백으로 변경

- 일급 함수로 어떤 함수에 동작 전달 가능
- 원래 있던 코드를 고차 함수로 만드는 강력한 방법
- 단계

  - 1. 함수 본문에서 바꿀 부분의 앞부분과 뒷부분 확인
  - 2. 리팩토링 할 코드를 함수로 분리
  - 3. 빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 분리

- 본문을 인자로 넘길 때 함수로 감싸서 넘김
  - 이유: 함수의 실행을 미루기 위해

### 일급인 것과 일급이 아닌 것 구별

**JS에서 일급이 아닌 것**

1. 수식 연산자
2. 반복문
3. 조건문
4. try/catch 블록

**JS에서 일급인 값이 할 수 있는 것**

1. 변수에 할당
2. 함수의 인자로 넘기기
3. 함수의 리턴값으로 받기
4. 배열이나 객체에 담기

- 로직을 함수화여 일급으로 바꿀 수 있음

- 일반적 엔티티는 개체와 배열처럼 일반 데이터 구조를 사용해야 함
- 이것이 데이터 지향 원칙

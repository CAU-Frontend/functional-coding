# 액션에서 계산 빼내기

입력과 출력 관점에서 바라봄

### 암묵적 입력과 암묵적 출력

1. 함수의 인자가 아닌 모든 외부 정보를 읽는 것은 암묵적 입력임
2. 함수의 반환값이 아닌 모든 반환값(화면 출력포함)은 암묵적 출력임

### 암묵적 입출력은 왜 문제가 되는가?

암묵적 입출력이 있다는 것은 함수의 지역값이 아닌, 외부의 값을 사용한다는 것임
이는

1. 유지보수하기 어렵게 만듦 -> 외부 값을 코드를 읽어가며 따라가야함
2. 재사용하기 어려워짐 -> 계산하여 바로 출력하는 경우, 계산부분을 재사용하기가 어려워짐
3. 테스트하기 힘듬

### 원칙

1. 암묵적 입력과 출력은 적을수록 좋다.
   암묵적 입출력 -> 납뗌
   명시적 입출력 -> 모듈 커넥터
2. 설계는 엉켜있는 코드를 푸는 것

### 계산 추출 과정

1. 계산 코드 빼내기
2. 새함수에 암묵적 입력과 출력 찾기
3. 암묵적 입력은 인자로, 출력은 리턴값으로 바꾸기

### 액션과 계산간의 구분

1. 변경될 수 있는 값을 읽는다면, 액션
2. 불변 값을 읽는 것은 계산

# 불변성

불변성은 액션을 계산으로 바꿔줄 수 있는 한가지 방법

### 데이터에 대한 동작의 구분

데이터에 대한 동작은 읽기와 쓰기 두가지로 분류됨
읽기에서는 데이터가 바뀌지 않음. 따라서 다루기 쉬움.

**쓰기**에서는 어떻게든 데이터를 바꿈
바뀌는 값은 어디서 사용할 지 모르기 때문에 바뀌지않도록 원칙이 필요함

이에 대한 원칙이 바로 copy-on-write

### Copy On Write

쓰기 전에 복사한다.
데이터 쓰기는 값을 변화시키고, 변화된 데이터는 어디서 쓰일지 모르기에, 이로 인한 혼란을 방지하고자 나오게 된 해결 방안

아래 두가지를 비교해보자.

```js
function add_element_last(array, element) {
  array.push(element);
}
```

첫번째요소는 인자로 들어온 array를 변경시킨다. 즉, array에 데이터를 쓰고있다.
add_element_last가 몇번 실행되는지에 따라 기존 array가 어떻게 변경되는지 이해하기란 매우매우매우 어렵다.

특히 여기에 비동기적으로 서버에서 데이터를 받아와서 업데이트까지 한다?
어떤 일이 일어나는지는 런타임만이 알 것이다.

반면 아래 코드를 보자.

```js
function add_element_last(array,element){
	return [....array,element]
}
```

위 코드는 읽기인가? 쓰기인가?
기존 인자로 들어온 array를 **읽기만 한다**는 것을 알 수 있다.

**쓰기를 읽기로 바꿈으로써, 더 많은 액션을 계산으로 바꿀 수 있게된다.**
더 많은 계산이 있을 수록, 개발할때, 맥락파악, 코드파악이 더 쉬워진다.

### Copy on write의 단점에 대한 반박

1. 언제든 최적화할 수 있음 -> 작은 코드이므로
2. 가비지 콜렉터의 성능은 생각보다 매우매우좋다.
3. 생각보다 많이 복사하지 않음 -> deep copy를 하는게 아닌, 얕은 복사를 하기에

### 방어적 복사

Copy-On-Write는 원칙으로써 혼란스러운 코드를 정리해주는 역할을함.
그러나, 라이브러리에서 내 데이터를 "쓰기" 해버린다면?
문제가 발생할 수 있음.

이러한 문제를 해결하기위해, 데이터의 입출력 통로에 deep copy를 해서 들여보내고, deep copy를 해서 내보내줌

이를 통해 외부와 내부가 분리되고, 내부안에서 여전히 안정성을 챙길 수 있게되고, 외부 코드는 외부코드대로 잘 작동하게 만들 수 있게됨

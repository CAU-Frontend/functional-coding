# 복습

- 액션

  - 호출하는 시점 & 횟수에 의존하는 코드

- 계산
  - 같은 값을 입력하면 항상 같은 값을 반환하는 코드

데이터 - 정적이고, 보이는 그대로 - 이벤트에 대한 사실

# 액션에서 계산 분리

### 테스트하기 쉽게 만들기기

```
function update_tax_dom() {
    set_tax_dom(shopping_cart_total * 0.10)
}
```

- set_tax_dom() => 계산한 세금을 화면에 업데이트하는 함수
- shopping_cart_total \* 0.10 => 테스트해야 하는 비즈니스 규칙
- shopping_cart_total => 해당 함수 테스트 전에 전역 변수 설정 필요

**테스트 개선을 위한 제안**

- DOM 업데이트와 비즈니스 규칙은 분리되어야 함

  - 비즈니스 규칙이 잘 실행되는지 확인하는 방법은 현재 DOM 업데이트를 기다리는 방법밖에 없음

- 전역 변수가 없다면 함수 테스트 불가한 상황

### 재사용하기 쉽게 만들기

```
function update_shipping_icons() {
    var buy_buttons = get_buy_buttons_dom();
    for (var i = 0; i < buy_buttons.length; i++) {
        var button = buy_buttons[i];
        var item = button.item;
        if (item.price + shopping_cart_total >= 20) {
            button.show_free_icon();
        } else if (item.pirce + shopping_cart_total < 20>) {
            button.hide_free_icon();
        }
    }
}
```

**재사용성을 위한 제안**

- 전역변수 값이 있어야만 실행 가능
- show, hide 함수는 DOM이 있을 때만 사용 가능
- 함수에 return 값이 없기 때문에 결과값을 받을 수 없는 함수

### 함수에는 입력과 출력이 존재

- 입력: 함수가 계산을 하기 위한 외부 정보
- 출력: 함수 밖으로 나오는 정보나 어떤 동작
- 함수를 부르는 이유는 결과가 필요하기 때문
- ex)
  - 인자 = 입력
  - 변수 읽기 = 입력
  - console.log = 출력
  - return = 출력

**입력과 출력은 명시적 or 암묵적으로 나뉜다**

- ex)
  - 인자 = 명시적 입력
  - 변수 읽기 = 암묵적 입력
  - console.log = 암묵적 출력
  - return = 명시적 출력

**함수에 암묵적 입력과 출력이 있으면 해당 함수는 액션**

- 암묵적 입력과 출력을 제거하면 해당 함수는 계산이 된다는 의미
- 암묵적 입력(전역변수 읽기) => 인자로 변경
- 암묵적 출력(console.log) => return 값으로 변경

함수형 프로그래머는 암묵적 입력과 출력을 **부수 효과**라고 부름

- 부수효과란?
  - return값 계산 외에 모든 일

**위에서 테스트 및 재사용성 개선을 위한 제안**
제안은 모두 암묵적 입력과 출력을 제거하자는 의미라고 볼 수 있다.

테스트

- DOM 업데이트와 비즈니스 규칙 분리 - DOM 업데이트 => 값 취득 === 출력 / return 값이 아니기 때문에 암묵적 출력 - DOM 업데이트는 필수적이기 때문에 DOM 업데이트와 비즈니스 규칙을 분리 제안
  재사용
- 전역변수를 읽는 것은 압묵적 입력, 값을 바꾸는 것은 암묵적 출력
- 결괏값을 return 하는 형식으로 변경 => 암묵적 출력을 명시적 출력으로 변경

결론 - 두 제안은 모두 암묵적 입력과 출력을 없애자는 제안

**💡원칙**
암묵적 입력과 출력은 적을수록 좋다.

- 액션에서도 모든 암묵적 입력과 출력을 없앨 수는 없다. 하지만 줄일수록 좋다.
- 어떤 함수에 암묵적 입력과 출력이 있다면 다른 컴포넌트와 강하게 연결된 컴포넌트라고 볼 수 있다.
  - 이는 모듈이 아니다.
- 명시적으로 바꾼다면 커넥터로 연결된 모듈처럼 사용이 가능하다.

### 액션에서 계산을 빼내는 방법

1. 계산에 해당하는 코드를 분리
2. 입력값은 인자로 변경
3. 출력값은 return 값으로 변경

```
function cal_cart_total() {
    cart_total = 0;
    for (var i = 0; i < cart.length; i++) {
        var item = cart[i];
        cart_total += item.price;
    }
    함수1();
    함수2();
}
```

위 코드를 아래와 같이 변경

1. 계산에 해당하는 코드 분리

- 분리한 코드를 새로운 함수로 만들고 네이밍
- 기존 코드에서 새로 만든 함수 호출
- 새 함수도 아직은 액션
- 기존 코드에서 동작은 그대로

이 리팩토링을 “서브루틴 추출하기”라고 부름

```
function cal__total() {
    cart_total = 0;
    for (var i = 0; i < cart.length; i++) {
        var item = cart[i];
        cart_total += item.price;
    }
}

function cal_cart_total() {
    cal_total();
    함수1();
    함수2();
}
```

3. 출력값을 return 값으로 변경

- 전역 변수를 지역 변수로 변경
- 지역 변수를 return
- 함수를 호출하는 쪽에서 전역변수에 값 할당

```
function cal__total() {
    var cart_total = 0;
    for (var i = 0; i < cart.length; i++) {
        var item = cart[i];
        cart_total += item.price;
    }
    return cart_total;
}

function cal_cart_total() {
    cart_total = cal_total();
    함수1();
    함수2();
}
```

2. 입력값을 인자로 변경

- 전역변수를 읽어오는 것은 암묵적 입력
- 전역변수 읽기 => 인자 전달로 변경

```
function cal_total(shopping_cart) {
    var cart_total = 0;
    for (var i = 0; i < shopping_cart.length; i++) {
        var item = cart[i];
        cart_total += item.price;
    }
    return cart_total;
}

function cal_cart_total() {
    cart_total = cal_total(shopping_cart);
    함수1();
    함수2();
}
```

이제 cal_total() 함수는 액션에서 계산이 됐다.
모든 입력은 인자이며 모든 출력은 return 값

# 더 좋은 액션 만들기

### 비즈니스 요구 사항과 설계를 맞추기

**요구 사항에 맞춰 더 나은 추상화 단계 선택하기**

- 요구 사항
  - 장바구니에 담긴 제품들의 주문 결과
  - 주문 결과로 무료 배송인지 여부 확인
  - 기존 함수에서는 합계 금액과 제품 가격을 더함
  - 요구 사항과 맞지 않는 인자(합계 금액, 제품 가격)
  - 장바구니에 담긴 제품들의 주문 결과가 인자로 들어가야 함

```
function gets_free_shipping(total, item_price){
    return item_price + total >= 20;
}
```

그리고 위에서 작성한 코드를 보면 total과 item_price의 합계를 구하는 코드가 이미 있기 때문에 다시 작성할 필요가 없음

```
function cal_total(shopping_cart) {
    var cart_total = 0;
    for (var i = 0; i < shopping_cart.length; i++) {
        var item = cart[i];
        cart_total += item.price;
    }
    return cart_total;
}
```

total 값을 이미 return 해주는 함수가 있기 때문에

```
function gets_free_shipping(cart){
    return cal_total(cart) >= 20;
}
```

으로 변경

계산 분류

**💡원칙**
설계는 엉켜있는 코드를 푸는 것

함수를 사용하면 관심사는 자연스레 분리
인자로 넘기는 값과 해당 값을 사용하는 방법을 분리
재사용 용이
유지보수 용이
테스트 용이
즉, 특별한 문제가 없어도 분리하는 것이 좋다 -> 더 좋은 설계가 된다

### 더 좋은 설계 만들기

```
function add_item(cart, name, price) {
    var new_cart = cart.slice();
    new_cart.push({
        name: name,
        price: price,
    });
    return new_cart;
}

add_item(cart, "shoes", 15);
```

```
function make_cart_item(name, price) {
    return {
        name: name,
        price: price,
    }
}

function add_item(cart, item) {
    var new_cart = cart.slice();
    new_cart.push(item);
    return new_cart;
}

add_item(cart, make_cart_item("shoes", 15));
```

item 구조만 담당하는 make_cart_item과 cart 구조를 담당하는 add_item 함수를 분리

### 카피-온-라이트 빼내기

```
function add_element_last(array, element) {
    var new_array = array.slice();
    new_array.push(element);
    return new_array;
}

function add_item(cart, item) {
    return add_element_last(cart, item);
}
```

- 어떤 배열이나 요소용 네이밍으로 변경
- 장바구니와 제품에만 사용하는 것이 아닌, 어떤 배열이나 요소에도 재사용이 가능한 유틸리티 함수가 됌

# 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

### 모든 동작을 불변형으로 만들 수 있나요?

앞에서 구현해봄
배열을 복사 => 값 변형 => RETURN

- 장바구니에 대한 동작
  1. 제품 개수 가져오기
  2. 제품 이름으로 제품 가져오기
  3. 제품 추가하기
  4. 제품 이름으로 제품 빼기
  5. 제품 이름으로 제품 구매 수량 바꾸기
     - 5번은 장바구니 내부의 제품 이름으로 장바구니 안에 제품의 정보를 변경해야 함
     - 이것이 중첩된 데이터

### 동작을 읽기, 쓰기, 둘 다로 분류

읽기 - 데이터에서 정보 가져오기 - 데이터를 변경하지 않음
인자에만 의존해 정보를 가져오는 읽기라면 계산
데이터를 바꾸지 않기 때문에 할 일이 없음

쓰기 - 데이터 변경
바뀌는 값은 어디서 사용될지 모르기 때문에 불변성 원칙에 따라 구현
불변성 원칙 === 카피-온-라이트

- 자바스크립트는 기본적으로 변경 가능한 데이터 구조를 사용 => 불변성 원칙을 직접 구현해야 함

### 카피-온-라이트 원칙

1단계 - 복사본 만들기
2단계 - 복사본 변경하기
3단계 - 복사본 리턴하기

인자로 받은 데이터를 바꾸지 않고, 값을 리턴했기 때문에 해당 함수는 “읽기”

카피-온-라이트 === 쓰기를 읽기로 바꾸는 것
배열에 요소를 추가하는 일이 있을 때, 카피-온-라이트를 용이하게 할 수 있는 함수가 됐다.

### 쓰기, 읽기를 동시에 하는 동작

.shift() -> 값을 바꾸는 동시에 배열의 첫 번째 항목을 읽어옴
값을 return하기 때문에 읽기
하지만 쓰기도 함
읽기와 쓰기로 각각 분리
함수에서 값을 2개 return
1번이 더 좋음 왜 => 책임이 확실하게 분리되기 때문

### 불변 데이터 구조

변경 가능한 데이터를 읽는 것 === 액션
쓰기는 데이터를 변경 가능한 구조로 만듦
쓰기를 모두 제거 === 불변 데이터
불변 데이터 구조를 읽는 것 === 계산 (언제 읽든, 몇 번을 읽든 데이터가 변경되지 않기 때문에 영향x)
쓰기를 읽기로 바꾸면 코드에 계산이 많아짐
매먼 복사하는 것은 너무 비효율적인 것이 아니냐
No 불변 데이터 구조를 사용하면서 대용량 고성능 시스템 구현 사례 多 => 일반 앱에서도 충분히 빠르다는 증거
언제든 최적화 가능
가비지 콜렉터는 매우 빠름
생각보다 많이 복사하지는 않음
빠른 구현체 존재

# 신뢰할 수 없는 코드를 사용하면서 불변성을 지키는 방법

### 레거시 코드와 불변성

레거시 코드 === 오~래전에 만든 코드라서 지금 당장 고칠 수 없어서 그대로 사용
값 변경을 위한 함수를 추가하여 원본 데이터에 영향을 미침 === 카피-온-라이트 원칙을 어기는 것
카피-온-라이트 원칙을 지키면서 안전하게 레거시 코드를 사용하는 다른 원칙
It’s 방어적 복사

### 신뢰할 수 없는 코드와의 상호작용

카피-온-라이트를 적용한 코드는 불변성이 보장되는 안전지대
외부에서 작성된 신뢰할 수 없는 코드와 상호작용 할 경우가 존재
안전지대 밖으로 데이터가 나간다면 불변성이 보장되지 않음
데이터가 바뀌는 것을 완벽하게 막아주는 방어적 복사 원칙을 적용해야 함

### 방어적 복사란?

원본이 변경되는 가능성을 차단하는 것
데이터가 들어올 때
신뢰할 수 없는 코드에 있는 데이터
데이터가 안전지대로 진입
데이터를 깊은 복사하여 안전지대에 저장
데이터가 나갈 때
안전지대에 있는 데이터
깊은 복사
복사한 데이터가 비안전지대로 진입
결론, 다 복사해둬라

### 방어적 복사 구현법

규칙 1. 데이터가 안전지대에서 나갈 때 복사해서 보내기
불변성 데이터를 위한 깊은 복사본 생성
신뢰 불가한 코드로 복사본을 전달

규칙 2. 안전한 코드로 데이터가 들어올 때 복사해두기
변경 가능한 데이터가 들어오면 깊은 복사본 생성
복사본을 안전지대에서 사용

### 깊은 복사와 얇은 복사

**깊은 복사**

- 완전히 독립적인 복사본 생성
- 원본 데이터와 공유 X
- 복사본을 수정해도 원본 데이터에 영향 無
- 원본 데이터가 클수록 복사 속도 느림

**얕은 복사**

- 참조 타입은 주소값만 복사
- 원본 데이터와 공유
- 복사본의 요소를 수정하면 원본 데이터에도 영향 有
- 원본 데이터의 크기와 상관없이 빠름

### 카피-온-라이트와 방어적 복사 비교

**카피-온-라이트**
When?

- 통제 가능한 데이터를 변경할 때
  Where?
- 안전지대 어디서든
- 카피-온-라이트가 안전지대를 만듦
  How?
- 얕은 복사(적은 비용)
  Rule?
- 바꿀 데이터의 얕은 복사를 생성
- 복사본 변경
- 복사본 리턴

**방어적 복사**
When?

- 신뢰 불가한 코드와 데이터 통신을 할 때
  Where?
- 안전지대 경계에서 데이터 통신을 할 때
  How?
- 깊은 복사(높은 비용)
  Rule?
- 안전지대로 들어오는 데이터에 깊은 복사 생성
- 안전지대에서 나가는 데이터에 깊은 복사 생성
